
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Strategies &#8212; IBEX 2.8 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="References" href="reference.html" />
    <link rel="prev" title="Sets" href="set.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="reference.html" title="References"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="set.html" title="Sets"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IBEX 2.8 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="strategies">
<h1>Strategies<a class="headerlink" href="#strategies" title="Permalink to this headline">¶</a></h1>
<div class="section" id="box-properties">
<span id="bxp"></span><h2>Box Properties<a class="headerlink" href="#box-properties" title="Permalink to this headline">¶</a></h2>
<p><strong>(In release 2.7)</strong></p>
<p>The box (<code class="docutils literal notranslate"><span class="pre">IntervalVector</span></code> class) is the central concept in Ibex and often this structure is too simple
and required to be extended.</p>
<p>Consider for example a search tree, such as the one performed by ibexsolve.
Assume you have several contractors involved in this search that need to calculate at some
point the image of the current box by a function <code class="docutils literal notranslate"><span class="pre">f</span></code>.
Imagine also that this function has quite a long expression so that calculating an image takes significant time:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// A contractor</span>
<span class="k">class</span> <span class="nc">MyCtc</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Ctc</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">contract</span><span class="p">(</span><span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Interval</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">eval</span><span class="p">(</span><span class="n">box</span><span class="p">);</span> <span class="c1">// this line is assumed to be expensive</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>Note:</strong> For simplicity, we assume from now on that <code class="docutils literal notranslate"><span class="pre">f</span></code> is a fixed object that has been declared somewhere in the context
(it could also be given in argument of all objects).</p>
<p>Recalculating this image each time a contractor is called represents a waste of time if
the box hasn’t changed meanwhile. One would like to store this information in the box.
This is the kind of things ‘’box properties’’ allow to do.</p>
<p>All is based on the <code class="docutils literal notranslate"><span class="pre">Bxp</span></code> interface. This <code class="docutils literal notranslate"><span class="pre">Bxp</span></code> interface allows to extend the simple <code class="docutils literal notranslate"><span class="pre">IntervalVector</span></code> data structure and to make this extension being propagated through a strategy (search tree). The extended box is then visible by all operators involved in the strategy (contractors, bisectors, cell buffers, etc.).</p>
<p>Note that the name of this interface is a trigram (like <code class="docutils literal notranslate"><span class="pre">Ctc</span></code> or <code class="docutils literal notranslate"><span class="pre">Bsc</span></code>)
just to encourage programers to prefix subclasses by <code class="docutils literal notranslate"><span class="pre">Bxp</span></code> (this is a recommended usage).
A box property, such as the image of the box by a given function, has to be a subclass of <code class="docutils literal notranslate"><span class="pre">Bxp</span></code> so let us name it <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BxpImage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Bxp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// to be completed...</span>

  <span class="n">Interval</span> <span class="n">image</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Of course, this class contains a field named <code class="docutils literal notranslate"><span class="pre">image</span></code> that will store the information.
We could also add whatever data needed.</p>
<div class="section" id="constructor">
<span id="bxp-construct"></span><h3>Constructor<a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h3>
<p>It is natural to ask the constructor of <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code> to take a box in argument and to set the <code class="docutils literal notranslate"><span class="pre">image</span></code> field appropriately.</p>
<p>The constructor of the mother class <code class="docutils literal notranslate"><span class="pre">Bxp</span></code> also requires an identifying number. Here is why. A box property is actually a set of <em>instances</em> of the <code class="docutils literal notranslate"><span class="pre">Bxp</span></code> interface: if the solver handles 1000 boxes at a given time, every box has it own image, hence its specific instance of <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code>. These 1000 instances represent the same ‘’property’’ and since there may be other properties attached to the boxes at the same time, we can retreive a given property thanks to its <code class="docutils literal notranslate"><span class="pre">id</span></code> field. (<strong>Note</strong>: using the class name directly as identifier would be too restrictive as there may be different <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code> properties attached to different functions <code class="docutils literal notranslate"><span class="pre">f</span></code>).
You can simply fix this identifier to any random <code class="docutils literal notranslate"><span class="pre">long</span></code> number or use the <code class="docutils literal notranslate"><span class="pre">next_id()</span></code> function of Ibex as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BxpImage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Bxp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">BxpImage</span><span class="p">(</span><span class="k">const</span> <span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">Bxp</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="n">image</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">eval</span><span class="p">(</span><span class="n">box</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>

  <span class="c1">// to be completed...</span>

  <span class="n">Interval</span> <span class="n">image</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">long</span> <span class="n">BxpImage</span><span class="o">::</span><span class="n">id</span> <span class="o">=</span> <span class="n">next_id</span><span class="p">();</span>
</pre></div>
</div>
<p><strong>Note</strong>: In the case of several <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code> properties (one for each function <code class="docutils literal notranslate"><span class="pre">f</span></code>) you can store identifying numbers in a map structure (see examples in the Ibex code).</p>
<p>To avoid confusion, we call for now “property value” an instance of the same property. So, <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code> is a property (or a set of properties, one for each <code class="docutils literal notranslate"><span class="pre">f</span></code>) and the instances of <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code> are property values.</p>
</div>
<div class="section" id="property-update">
<span id="bxp-update"></span><h3>Property update<a class="headerlink" href="#property-update" title="Permalink to this headline">¶</a></h3>
<p>The next step is to specify how property values are updated when the box is modified.
This amounts to implement an <code class="docutils literal notranslate"><span class="pre">update(...)</span></code> function as follows. This function will
be called at different points of the stragegy, through the <em>trust chain</em> principle
to be explained further.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="k">const</span> <span class="n">BoxEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">,</span> <span class="k">const</span> <span class="n">BoxProperties</span><span class="o">&amp;</span> <span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">eval</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">box</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Note that a <a class="reference internal" href="#bxp-lazy"><span class="std std-ref">smarter implementation</span></a> is often desired.
This is however not enough. You also have to state how the property is transformed
when the box is copied (copies occur in a search each time a box is bisected
or, e.g., to perform some temporary computations). This is done by implementing the <code class="docutils literal notranslate"><span class="pre">copy()</span></code> function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">Bxp</span><span class="o">*</span> <span class="nf">copy</span><span class="p">(</span><span class="k">const</span> <span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">,</span> <span class="k">const</span> <span class="n">BoxProperties</span><span class="o">&amp;</span> <span class="n">prop</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">BxpImage</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// implicit copy constructor is fine</span>
  <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="using-properties">
<span id="bxp-using"></span><h3>Using properties<a class="headerlink" href="#using-properties" title="Permalink to this headline">¶</a></h3>
<p>Now, let us modify the implementation of our contractor.
To take benefit of properties, two steps are required.
First, we have to override the <code class="docutils literal notranslate"><span class="pre">add_property</span></code> function of the <code class="docutils literal notranslate"><span class="pre">Ctc</span></code> interface.
This function is called by all strategies at initialization.
This function takes as argument the initial box (of the search) and a container for property values: an instance of <code class="docutils literal notranslate"><span class="pre">BoxProperties</span></code>. This object basically just stores pointers to <code class="docutils literal notranslate"><span class="pre">Bxp*</span></code>, except that it can handle <a class="reference internal" href="#bxp-dependencies"><span class="std std-ref">inter-dependencies</span></a>.</p>
<p>Second, we have to override a variant of the <code class="docutils literal notranslate"><span class="pre">contract</span></code> function,
which takes in argument not only the box, but also a <code class="docutils literal notranslate"><span class="pre">ContractContext</span></code> object which contains, among other things, the current property values container (again, an instance of <code class="docutils literal notranslate"><span class="pre">BoxProperties</span></code>).
The <code class="docutils literal notranslate"><span class="pre">BoxProperties</span></code> class works like a simple map: by using the bracket operator <code class="docutils literal notranslate"><span class="pre">[...]</span></code>
with the property id inside the brackets, you get the corresponding property value associated to the box:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyCtc</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Ctc</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="cm">/* Add the required property inside the map.</span>
<span class="cm">   * (This function is automatically called by the search). */</span>
  <span class="kt">void</span> <span class="n">add_property</span><span class="p">(</span><span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">,</span> <span class="n">BoxProperties</span><span class="o">&amp;</span> <span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// if the property is not already in the list</span>
    <span class="c1">// (which is possible since another operator requiring it may</span>
    <span class="c1">// have already added it)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">[</span><span class="n">BxpImage</span><span class="o">::</span><span class="n">id</span><span class="p">])</span>
      <span class="c1">// create an initial property value, and add it</span>
      <span class="n">prop</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span> <span class="n">BxpImage</span><span class="p">(</span><span class="n">box</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cm">/* Contract a box with associated properties. */</span>
  <span class="kt">void</span> <span class="n">contract</span><span class="p">(</span><span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">,</span> <span class="n">ContractContext</span><span class="o">&amp;</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Get the desired property from the map, by its id</span>
    <span class="c1">// (a cast is necessary because all properties are typed Bxp*)</span>
    <span class="n">BxpImage</span><span class="o">*</span> <span class="n">bxp</span><span class="o">=</span><span class="p">(</span><span class="n">BxpImage</span><span class="o">*</span><span class="p">)</span> <span class="n">context</span><span class="p">.</span><span class="n">prop</span><span class="p">[</span><span class="n">BxpImage</span><span class="o">::</span><span class="n">id</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bxp</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// This happens if the property is not present.</span>
      <span class="c1">// It is much more safe to handle this case</span>
      <span class="c1">// ...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Obtain directly the image (without recalculating it)</span>
      <span class="n">Interval</span> <span class="n">y</span><span class="o">=</span><span class="n">bxp</span><span class="o">-&gt;</span><span class="n">image</span><span class="p">;</span>
      <span class="c1">// .....</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="lazy-update">
<span id="bxp-lazy"></span><h3>Lazy update<a class="headerlink" href="#lazy-update" title="Permalink to this headline">¶</a></h3>
<p>So far, we have centralized in a unique place the result of the image computation which is already good but
not optimal at all. Worse, the running time of our program will likely be longer than without
introducing this property! Indeed, the <code class="docutils literal notranslate"><span class="pre">update</span></code> function will be called basically whenever an operator
change the box, which means that the funtion f will be evaluated again and again!</p>
<p>This event-oriented design of a property can be sometimes interesting but, clearly, it does not fit well here.</p>
<p>What we actually want is the function to postpone the evaluation at the latest time, that is, when someone requires it.
This is called laziness. This principle can be simply applied here as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BxpImage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Bxp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// The class contains 2 new fields:</span>
  <span class="c1">// box: a reference to the box needs to be stored</span>
  <span class="c1">// to perform the evaluation at any time.</span>
  <span class="c1">// up2date: memorize whether the image is up to date.</span>
  <span class="n">BxpImage</span><span class="p">(</span><span class="k">const</span> <span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">)</span> <span class="o">:</span> <span class="n">Bxp</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="n">box</span><span class="p">(</span><span class="n">box</span><span class="p">),</span> <span class="n">up2date</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="k">const</span> <span class="n">BoxEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">,</span> <span class="k">const</span> <span class="n">BoxProperties</span><span class="o">&amp;</span> <span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do nothing for the moment!</span>
    <span class="n">up2date</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Bxp</span><span class="o">*</span> <span class="n">copy</span><span class="p">(</span><span class="k">const</span> <span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">,</span> <span class="k">const</span> <span class="n">BoxProperties</span><span class="o">&amp;</span> <span class="n">prop</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">BxpImage</span><span class="p">(</span><span class="n">box</span><span class="p">,</span><span class="n">image</span><span class="p">,</span><span class="n">up2date</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Return the image of f.</span>
  <span class="k">const</span> <span class="n">Interval</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">up2date</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">image</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">eval</span><span class="p">(</span><span class="n">box</span><span class="p">);</span>
      <span class="n">up2date</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">image</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="n">BxpImage</span><span class="p">(</span><span class="k">const</span> <span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">,</span> <span class="k">const</span> <span class="n">Interval</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">up2date</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">Bxp</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="n">box</span><span class="p">(</span><span class="n">box</span><span class="p">),</span> <span class="n">image</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="n">up2date</span><span class="p">(</span><span class="n">up2date</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

  <span class="k">const</span> <span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">;</span>
  <span class="n">Interval</span> <span class="n">image</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">up2date</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>It is easy to adapt this code so that an update is performed only when the box modification is significant (e.g., when
a contraction removes more than 1% of a component width).</p>
</div>
<div class="section" id="dependencies">
<span id="bxp-dependencies"></span><h3>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<p>It may happen that a property is based on another one.
Imagine that you want to create a property that stores the width of the function image
(of course, this example is caricatural as the width is not something you really need to store).
You can extend the <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code> class but you can also create a separate property, say <code class="docutils literal notranslate"><span class="pre">BxpImageWidth</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">BxpImageWidth</span></code> need to “see” the <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code> property in the <code class="docutils literal notranslate"><span class="pre">update_xxx(...)</span></code> function. This is why there is also a <code class="docutils literal notranslate"><span class="pre">BoxProperties</span></code> map in the argument of these functions.
Furthermore, we must be sure that the <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code> is updated before <code class="docutils literal notranslate"><span class="pre">BxpImageWidth</span></code>. To this end, we simply have to add the
identifier of <code class="docutils literal notranslate"><span class="pre">BxpImage</span></code> in the <em>dependencies</em> of <code class="docutils literal notranslate"><span class="pre">BxpImageWidth</span></code>. This must be done in the constructor of <code class="docutils literal notranslate"><span class="pre">BxpImageWidth</span></code> as shown in the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BxpImageWidth</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Bxp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">BxpImageWidth</span><span class="p">(</span><span class="k">const</span> <span class="n">IntervalVector</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">)</span> <span class="o">:</span> <span class="n">Bxp</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="n">w</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">max_diam</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// dependencies is a field inherited from Bxp</span>
    <span class="n">dependencies</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">BxpImage</span><span class="o">::</span><span class="n">id</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="k">const</span> <span class="n">BoxEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">,</span> <span class="k">const</span> <span class="n">BoxProperties</span><span class="o">&amp;</span> <span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BxpImage</span><span class="o">*</span> <span class="n">bxp</span><span class="o">=</span><span class="p">(</span><span class="n">BxpImage</span><span class="o">*</span><span class="p">)</span> <span class="n">prop</span><span class="p">[</span><span class="n">BxpImage</span><span class="o">::</span><span class="n">id</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bxp</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// This happens if the property is not present.</span>
      <span class="c1">// It is much more safe to handle this case</span>
      <span class="c1">// ...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="c1">// note: we lose laziness here</span>
      <span class="n">w</span><span class="o">=</span><span class="n">bxp</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">().</span><span class="n">diam</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">double</span> <span class="n">w</span><span class="p">;</span> <span class="c1">// the width</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For the sake of concision, we haven’t used laziness in this code. A lazy variant is necessary here.</p>
</div>
<div class="section" id="trust-chain-principle">
<h3>Trust chain principle<a class="headerlink" href="#trust-chain-principle" title="Permalink to this headline">¶</a></h3>
<p>The trust chain principle is the following:</p>
<ul class="simple">
<li><p>Property values are always up-to-date when given to argument of a function.</p></li>
</ul>
<p>Consider a function that handles properties (e.g., an implementation of the <code class="docutils literal notranslate"><span class="pre">contract</span></code> variant with <code class="docutils literal notranslate"><span class="pre">BoxProperties</span></code>, as above).
It the box is modified at several points in the code, it is not necessary to perform updates as long
as properties are not used elsewhere. The update can be postponed to the
point where property values are transmitted to another function or, on last resort, before returning.</p>
<p>Note that updating all property values can be simply done via the <code class="docutils literal notranslate"><span class="pre">update</span></code> function of <code class="docutils literal notranslate"><span class="pre">BoxProperties</span></code> (this
also allows to respect dependencies).</p>
<p>As a consequence, if the function does not modify itself the box (would it calls other functions that potentially modify it), it does not
have to perform at all any update of property values.</p>
</div>
</div>
<div class="section" id="cov-files">
<span id="cov"></span><h2>COV files<a class="headerlink" href="#cov-files" title="Permalink to this headline">¶</a></h2>
<p>File Input/Output operations in Ibex are based on the COV format.</p>
<p>The COV format is actually a <em>family</em> of formats because Ibex is a library
upon which different executables are built, each handling different types of data.
There is no one-fits-all definition in this context.
When we talk about ‘programs’ we mean not only the official ones supplied with
the library itself (like <code class="docutils literal notranslate"><span class="pre">ibexsolve</span></code>, <code class="docutils literal notranslate"><span class="pre">ibexopt</span></code>, …) but all the programs that
can be potentially developed by Ibex users.</p>
<p>The common point of these programs is that they usually calculate sets with boxes,
because this is what Ibex is all about.
More precisely, they calculate boxes that form a <em>covering</em> of some set, whence the
name ‘COV’.</p>
<p>So, instead of creating a monolithic file format for each program, we can imagine a
file format made of two parts:</p>
<ul class="simple">
<li><p>a part common to all programs containing a description of the covering;</p></li>
<li><p>a part specific to each program gathering additional information handled by the proram.</p></li>
</ul>
<p>This way, all the programs can now exchange data by extracting from a file the
common part. Let us call this part after the corresponding C++ class: <code class="docutils literal notranslate"><span class="pre">CovList</span></code>.</p>
<p>In fact, we can go a step further.
In a covering of a set, we often distinguish <em>inner</em> boxes, that is, the ones that
are proven to be inside the set,  and <em>unknwon</em> boxes, the other ones.
But not all programs do. So, instead of replacing the <code class="docutils literal notranslate"><span class="pre">CovList</span></code> by a more elaborated
structure, we rather insert an intermediate level of information in the format; now,
a program that makes a distinction between inner and unknown boxes has an associated
file format made of three parts:</p>
<ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">CovList</span></code> part that tells which boxes form the covering</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">CovIUList</span></code> part that tells which among the <code class="docutils literal notranslate"><span class="pre">CovList</span></code> boxes are inner (&lt;-&gt; ‘I’), the
other being implicitly unknown (&lt;-&gt; ‘U’).</p></li>
<li><p>the part specific to the program</p></li>
</ul>
<p>This way, the program can communicate with another one handling inner boxes. But
it can still communicate with all the other programs through the <code class="docutils literal notranslate"><span class="pre">CovList</span></code> level.</p>
<p>This principle can be extended to any level and gives rise to a hierarchy of formats,
where each level refines the semantics of the previous one. This is how the COV format works.
This principle allows programs to store and exchange data at the right level
and without restriction on what amount of data they actually need.
The top-level format is not <code class="docutils literal notranslate"><span class="pre">CovList</span></code> in fact, but something more general simply called <code class="docutils literal notranslate"><span class="pre">Cov</span></code>,
because we may represent a covering by something else than a list (example: a quadtree).</p>
<p>The file format managed by <code class="docutils literal notranslate"><span class="pre">ibexsolve</span></code> is called <code class="docutils literal notranslate"><span class="pre">CovSolverData</span></code> and is 5 levels
below the root format <code class="docutils literal notranslate"><span class="pre">Cov</span></code>. We have:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Cov</span></code>: a covering (root format)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CovList</span></code>: a Cov described by a list of boxes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CovIUList</span></code>: a Covlist with some boxes marked as <em>inner</em></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CovIBUList</span></code>: a CovIUlist with some boxes marked as <em>boundary</em></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CovManifold</span></code>: a CovIBUList with some boxes marked as <em>solutions</em> (i.e., they enclose
a subset of the manifold in a precise way).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CovSolverData</span></code>: a CovManifold with additional data related to the solving process</p></li>
</ul>
<div class="section" id="first-example">
<h3>First example<a class="headerlink" href="#first-example" title="Permalink to this headline">¶</a></h3>
<p>We illustrate the usage of COV files with <code class="docutils literal notranslate"><span class="pre">ibexsolve</span></code>.
Let us first solve a simple problem, like an inequality:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// create a simple inequality x^2+y^2&lt;=1.</span>
<span class="k">const</span> <span class="n">ExprSymbol</span><span class="o">&amp;</span> <span class="n">x</span><span class="o">=</span><span class="n">ExprSymbol</span><span class="o">::</span><span class="n">new_</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="k">const</span> <span class="n">ExprSymbol</span><span class="o">&amp;</span> <span class="n">y</span><span class="o">=</span><span class="n">ExprSymbol</span><span class="o">::</span><span class="n">new_</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">);</span>
<span class="n">SystemFactory</span> <span class="n">fac</span><span class="p">;</span>
<span class="n">fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">fac</span><span class="p">.</span><span class="n">add_ctr</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">sqr</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">);</span>

<span class="n">System</span> <span class="nf">sys</span><span class="p">(</span><span class="n">fac</span><span class="p">);</span>

<span class="c1">// run the solver with a coarse precision (1.0)</span>
<span class="c1">// to have a limited number of boxes</span>
<span class="n">DefaultSolver</span> <span class="nf">solver</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// we set a very short storage capacity</span>
<span class="c1">// to have a partial solving only.</span>
<span class="n">solver</span><span class="p">.</span><span class="n">cell_limit</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

<span class="n">solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">box</span><span class="p">);</span>
</pre></div>
</div>
<p>The result of the solver is a COV object we can access to with the <code class="docutils literal notranslate"><span class="pre">get_data</span></code> function.
So, we can cast the returned object to a <code class="docutils literal notranslate"><span class="pre">CovList</span></code> and access to the result as
a simple list of boxes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">CovList</span><span class="o">&amp;</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">get_data</span><span class="p">();</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;The list contains &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cov</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; boxes&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cov</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;box n°&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>The list contains 7 boxes
box n°0 = ([-0.99503768772846, -0.09999999999999997] ; [-0.9949874371066201, -0.09949874371066191])
box n°1 = ([-1, -0.09999999999999997] ; [-0.09949874371066192, 0.3930200376571151])
box n°2 = ([-0.9195299070720865, -0.09999999999999997] ; [0.393020037657115, 0.9949874371066201])
box n°3 = ([-0.09999999999999998, 0.3927443466979792] ; [-1, -0.09999999999999997])
box n°4 = ([0.3927443466979791, 0.9949874371066201] ; [-0.9196476924000722, -0.09999999999999997])
box n°5 = ([-0.09999999999999998, 0.3950000000000002] ; [-0.09999999999999998, 1])
box n°6 = ([0.3950000000000001, 1] ; [-0.09999999999999998, 1])
</pre></div>
</div>
<p>We can also cast the object to a <code class="docutils literal notranslate"><span class="pre">CovIUList</span></code> and access to the result as two
lists: the list of inner boxes and the list of unknown boxes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">CovIUList</span><span class="o">&amp;</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">get_data</span><span class="p">();</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Inner boxes:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cov</span><span class="p">.</span><span class="n">nb_inner</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;inner n°&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cov</span><span class="p">.</span><span class="n">inner</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unknown boxes:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cov</span><span class="p">.</span><span class="n">nb_unknown</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;unknown n°&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cov</span><span class="p">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Inner boxes:

Unknown boxes:
unknown n°0 = ([-0.99503768772846, -0.09999999999999997] ; [-0.9949874371066201, -0.09949874371066191])
unknown n°1 = ([-1, -0.09999999999999997] ; [-0.09949874371066192, 0.3930200376571151])
unknown n°2 = ([-0.9195299070720865, -0.09999999999999997] ; [0.393020037657115, 0.9949874371066201])
unknown n°3 = ([-0.09999999999999998, 0.3927443466979792] ; [-1, -0.09999999999999997])
unknown n°4 = ([0.3927443466979791, 0.9949874371066201] ; [-0.9196476924000722, -0.09999999999999997])
unknown n°5 = ([-0.09999999999999998, 0.3950000000000002] ; [-0.09999999999999998, 1])
unknown n°6 = ([0.3950000000000001, 1] ; [-0.09999999999999998, 1])
</pre></div>
</div>
<p>We jump now directly to the <code class="docutils literal notranslate"><span class="pre">CovSolverData</span></code> format.
Among other things, the format distinguishes two types of boxes
in the unknown boxes in the <code class="docutils literal notranslate"><span class="pre">CovManifold</span></code> view:</p>
<ul class="simple">
<li><p>the boxes that have reached the precision (1.0) and which could neither
be proven to be inner or outer. They are also called <em>unknown</em> at the
<code class="docutils literal notranslate"><span class="pre">CovSolverData</span></code> level.</p></li>
<li><p>the boxes that have not been processed because the solving process
was interrupted for whatever reason (time out or cell overflow).
They are called <em>pending</em> boxes.</p></li>
</ul>
<p>We can seen now that the solver was actually interrupted because
of the cell limit we fixed:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">CovSolverData</span><span class="o">&amp;</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">get_data</span><span class="p">();</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Inner boxes:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cov</span><span class="p">.</span><span class="n">nb_inner</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;inner n°&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cov</span><span class="p">.</span><span class="n">inner</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unknown boxes:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cov</span><span class="p">.</span><span class="n">nb_unknown</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;unknown n°&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cov</span><span class="p">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Pending boxes:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cov</span><span class="p">.</span><span class="n">nb_pending</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Pending n°&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cov</span><span class="p">.</span><span class="n">pending</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Inner boxes:

Unknown boxes:
unknown n°0 = ([-0.99503768772846, -0.09999999999999997] ; [-0.9949874371066201, -0.09949874371066191])
unknown n°1 = ([-1, -0.09999999999999997] ; [-0.09949874371066192, 0.3930200376571151])
unknown n°2 = ([-0.9195299070720865, -0.09999999999999997] ; [0.393020037657115, 0.9949874371066201])
unknown n°3 = ([-0.09999999999999998, 0.3927443466979792] ; [-1, -0.09999999999999997])
unknown n°4 = ([0.3927443466979791, 0.9949874371066201] ; [-0.9196476924000722, -0.09999999999999997])

Pending boxes:
Pending n°0 = ([-0.09999999999999998, 0.3950000000000002] ; [-0.09999999999999998, 1])
Pending n°1 = ([0.3950000000000001, 1] ; [-0.09999999999999998, 1])
</pre></div>
</div>
</div>
<div class="section" id="exchanging-data-between-ibexsolve-and-ibexopt">
<h3>Exchanging data between IbexSolve and IbexOpt<a class="headerlink" href="#exchanging-data-between-ibexsolve-and-ibexopt" title="Permalink to this headline">¶</a></h3>
<p>The power of COV files is now illustrated by feeding the optimizer
with the output of the solver and vice versa.</p>
<p>To this end, we consider a problem where we optimize a simple criterion
(x+y) over the inequality x^2+y^2&lt;=1. But instead of running the optimizer with the overall
problem, we treat the constraint and the criterion separately: we
first produce a covering of the constraint with the solver
and then apply the unconstrained optimizer on the covering.</p>
<p>We have already built in the previous example the system <code class="docutils literal notranslate"><span class="pre">sys</span></code>. Let us
run the solver with a higher precision:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// solve the problem with boundary boxes</span>
<span class="c1">// of diameter &lt; 0.1</span>
<span class="n">DefaultSolver</span> <span class="nf">solver</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">);</span>
<span class="n">solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">box</span><span class="p">);</span>
</pre></div>
</div>
<p>Let us now build the system representing the unconstrained optimization problem:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SystemFactory</span> <span class="n">opt_fac</span><span class="p">;</span>
<span class="n">opt_fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">opt_fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">opt_fac</span><span class="p">.</span><span class="n">add_goal</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">);</span>

<span class="n">System</span> <span class="nf">opt</span><span class="p">(</span><span class="n">opt_fac</span><span class="p">);</span>
</pre></div>
</div>
<p>And now, we run the optimizer on the solver output:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">DefaultOptimizer</span> <span class="nf">optim</span><span class="p">(</span><span class="n">opt</span><span class="p">);</span>

<span class="c1">// run the optimizer with solver data as input covering:</span>
<span class="n">optim</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="n">get_data</span><span class="p">());</span>

<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; best bound=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">optim</span><span class="p">.</span><span class="n">get_loup</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">best</span> <span class="n">bound</span><span class="o">=-</span><span class="mf">1.48244</span>
</pre></div>
</div>
<p>Let us do it now in the other way around.
We first run the optimizer on the objective function abs(x^2+y^2-1) so that the whole unit circle is made of global minima.
However, if we set the problem like this, the optimizer quickly converges to a unique global minimum because it
resorts to some ‘anticipated’ bounding techniques.
To force the optimizer to keep all the circle, we replace the constant 1 by an interval thicker than the optimizer precision:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// build the problem &quot;minimize |x^2+y^2-1|&quot;</span>
<span class="c1">// -------------------------------------</span>
<span class="n">Function</span> <span class="nf">g</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span><span class="s">&quot;y&quot;</span><span class="p">,</span><span class="s">&quot;abs(x^2+y^2-[0.9,1.1])&quot;)</span><span class="p">;</span>
<span class="n">SystemFactory</span> <span class="n">opt_fac</span><span class="p">;</span>
<span class="n">opt_fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">args</span><span class="p">());</span>
<span class="n">opt_fac</span><span class="p">.</span><span class="n">add_goal</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
<span class="n">System</span> <span class="nf">opt</span><span class="p">(</span><span class="n">opt_fac</span><span class="p">);</span>

<span class="c1">// we need bounded domain for unconstrained optimization:</span>
<span class="n">opt</span><span class="p">.</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">Interval</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
<span class="n">opt</span><span class="p">.</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">Interval</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
<span class="c1">// -------------------------------------</span>
</pre></div>
</div>
<p>Then we run the optimizer. We fix a timeout to prevent him from bisecting again and again inside the thick circle.
This way, we obtain a coarse approximation of the circle.
If we want to communicate the result to the solver, an extra instruction is also necessary; Indeed, by default, the optimizer generates
a COV file in the <em>extended space</em>, that is, it generates 3 dimensional boxes, the third dimension corresponding to
the objective values. By default, a box in the optimizer data is ([x],[y],f([x],[y]). If we feed the solver with such
boxes, it will refuse with a dimension mismatching error message. So we need to configure the optimizer
so that only variables domains are produced.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// solve it</span>
<span class="n">DefaultOptimizerConfig</span> <span class="nf">optim_config</span><span class="p">(</span><span class="n">opt</span><span class="p">);</span> <span class="c1">// 1 is a very coarse precision</span>
<span class="n">Optimizer</span> <span class="nf">optim</span><span class="p">(</span><span class="n">optim_config</span><span class="p">);</span>
<span class="n">optim</span><span class="p">.</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">optim</span><span class="p">.</span><span class="n">extended_COV</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">optim</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">box</span><span class="p">);</span>
</pre></div>
</div>
<p>We can now build the solver to solve a constraint, like x-y=0.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Build the system &quot;solve x+y=0&quot;</span>
<span class="c1">// -------------------------------------</span>
<span class="n">Function</span> <span class="nf">f</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span><span class="s">&quot;y&quot;</span><span class="p">,</span><span class="s">&quot;x-y&quot;</span><span class="p">);</span>
<span class="n">NumConstraint</span> <span class="nf">c</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="n">SystemFactory</span> <span class="n">sys_fac</span><span class="p">;</span>
<span class="n">sys_fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">args</span><span class="p">());</span>
<span class="n">sys_fac</span><span class="p">.</span><span class="n">add_ctr</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="n">System</span> <span class="nf">sys</span><span class="p">(</span><span class="n">sys_fac</span><span class="p">);</span>
<span class="c1">// -------------------------------------</span>
</pre></div>
</div>
<p>and feed it with the optimizer data:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// solve the problem</span>
<span class="n">DefaultSolver</span> <span class="nf">solver</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">);</span>
<span class="n">solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">optim</span><span class="p">.</span><span class="n">get_data</span><span class="p">());</span>
<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">solver</span><span class="p">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>The output indeeds contains a sequence of boxes enclosing the intersection of the
unit circle and the line x=y:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> solution n°1 = ([-0, 0.06080690561079815] ; [0, 0.06080690561079815])
 solution n°2 = ([0.06080690561079814, 0.1351264569128848] ; [0.06080690561079814, 0.1351264569128848])
 solution n°3 = ([0.1351264569128847, 0.2094460082149714] ; [0.1351264569128847, 0.2094460082149714])
 solution n°4 = ([0.2094460082149713, 0.3002810153619661] ; [0.2094460082149713, 0.3002810153619661])
 solution n°5 = ([0.300281015361966, 0.3746005666640527] ; [0.300281015361966, 0.3746005666640527])
 solution n°6 = ([0.3746005666640526, 0.4654355738110474] ; [0.3746005666640526, 0.4654355738110474])
 solution n°7 = ([0.4654355738110473, 0.5562705809580422] ; [0.4654355738110473, 0.5562705809580422])
 solution n°8 = ([0.5562705809580421, 0.6062298348888893] ; [0.5562705809580421, 0.6062298348888893])
 solution n°9 = ([0.6062298348888892, 0.6672911452488134] ; [0.6062298348888892, 0.6672911452488134])
 solution n°10 = ([0.6672911452488133, 0.7416106965509001] ; [0.6672911452488133, 0.7416106965509001])
 solution n°11 = ([0.7416106965509, 0.8324457036978949] ; [0.7416106965509, 0.8324457036978949])
 solution n°12 = ([0.8324457036978948, 0.9232807108448897] ; [0.8324457036978948, 0.9232807108448897])
 solution n°13 = ([0.9232807108448896, 0.9732399647757368] ; [0.9232807108448896, 0.9732399647757368])
 solution n°14 = ([0.9732399647757367, 1.034301275135661] ; [0.9732399647757367, 1.034301275135661])
 solution n°15 = ([1.03430127513566, 1.125136282282656] ; [1.03430127513566, 1.125136282282656])
 solution n°16 = ([1.125136282282655, 1.175095536213503] ; [1.125136282282655, 1.175095536213503])
 solution n°17 = ([1.175095536213502, 1.236156846573427] ; [1.175095536213502, 1.236156846573427])
 solution n°18 = ([1.236156846573426, 1.286116100504275] ; [1.236156846573426, 1.286116100504275])
 solution n°19 = ([1.286116100504274, 1.347177410864199] ; [1.286116100504274, 1.347177410864199])
 solution n°20 = ([1.347177410864198, 1.408238721224123] ; [1.347177410864198, 1.408238721224123])
 solution n°21 = ([1.408238721224122, 1.48286921166403] ; [1.408238721224122, 1.48286921166403])
 solution n°22 = ([-1.211995277094166, -1.162295895762822] ; [-1.211995277094166, -1.162295895762822])
 solution n°23 = ([-1.162295895762823, -1.101552207468959] ; [-1.162295895762823, -1.101552207468959])
 solution n°24 = ([-1.10155220746896, -1.040808519175096] ; [-1.10155220746896, -1.040808519175096])
 solution n°25 = ([-1.040808519175097, -0.9665662334825967] ; [-1.040808519175097, -0.9665662334825967])
 solution n°26 = ([-0.9665662334825968, -0.9058225451887335] ; [-0.9665662334825968, -0.9058225451887335])
 solution n°27 = ([-0.9058225451887336, -0.831580259496234] ; [-0.9058225451887336, -0.831580259496234])
 solution n°28 = ([-0.8315802594962341, -0.7573379738037345] ; [-0.8315802594962341, -0.7573379738037345])
 solution n°29 = ([-0.7573379738037346, -0.6665974024017908] ; [-0.7573379738037346, -0.6665974024017908])
 solution n°30 = ([-0.6665974024017909, -0.6058537141079276] ; [-0.6665974024017909, -0.6058537141079276])
 solution n°31 = ([-0.6058537141079277, -0.5316114284154281] ; [-0.6058537141079277, -0.5316114284154281])
 solution n°32 = ([-0.5316114284154282, -0.4573691427229287] ; [-0.5316114284154282, -0.4573691427229287])
 solution n°33 = ([-0.4573691427229288, -0.3666285713209849] ; [-0.4573691427229288, -0.3666285713209849])
 solution n°34 = ([-0.366628571320985, -0.2923862856284854] ; [-0.366628571320985, -0.2923862856284854])
 solution n°35 = ([-0.2923862856284855, -0.2016457142265417] ; [-0.2923862856284855, -0.2016457142265417])
 solution n°36 = ([-0.2016457142265418, -0.1109051428245979] ; [-0.2016457142265418, -0.1109051428245979])
 solution n°37 = ([-0.110905142824598, -0.06099782855352885] ; [-0.110905142824598, -0.06099782855352885])
 solution n°38 = ([-0.06099782855352886, 0] ; [-0.06099782855352886, -0])

</pre></div>
</div>
</div>
</div>
<div class="section" id="bisectors">
<span id="strategy-bisectors"></span><h2>Bisectors<a class="headerlink" href="#bisectors" title="Permalink to this headline">¶</a></h2>
<p>A bisector is an operator that takes a box <span class="math notranslate nohighlight">\([x]\)</span> as input and returns two sub-boxes <span class="math notranslate nohighlight">\(([x]^{(1)},[x]^{(2)})\)</span> that
form a partition of <span class="math notranslate nohighlight">\([x]\)</span>, that is, <span class="math notranslate nohighlight">\([x]=[x]^{(1)}\cup[x]^{(2)}\)</span>. This partition is obtained by
selecting one component <span class="math notranslate nohighlight">\([x_i]\)</span> and splitting this interval at some point.</p>
<p>Each bisector implements a specific strategy for chosing the component. The bisection point in the interval is
defined as a <em>ratio</em> of the interval width, e.g., a ratio of 0.5 corresponds to the midpoint.</p>
<div class="section" id="bisecting-each-component-in-turn">
<h3>Bisecting each component in turn<a class="headerlink" href="#bisecting-each-component-in-turn" title="Permalink to this headline">¶</a></h3>
<p><em>(to be completed)</em></p>
</div>
<div class="section" id="bisecting-the-largest-component">
<h3>Bisecting the largest component<a class="headerlink" href="#bisecting-the-largest-component" title="Permalink to this headline">¶</a></h3>
<p><em>(to be completed)</em></p>
</div>
<div class="section" id="setting-different-precision-for-variables">
<h3>Setting different precision for variables<a class="headerlink" href="#setting-different-precision-for-variables" title="Permalink to this headline">¶</a></h3>
<p>In real-world applications, variables often correspond to physical quantities with different units.
The order of magnitude greatly varies with the unit.
For example, consider Coulomb’s law:</p>
<div class="math notranslate nohighlight">
\[F=k_e\frac{q_1q_2}{r^2}\]</div>
<p>applied to two charges <span class="math notranslate nohighlight">\(q_1\)</span> and <span class="math notranslate nohighlight">\(q_2\)</span> or ~1e-6 coulomb, with a distance <span class="math notranslate nohighlight">\(r\)</span> of ~1e-2 meter.
With Coulomb’s contant ~ 1e10, the resulting force will be in the order of 1e2 Newton.</p>
<p>If one introduces Coulomb’s equation in a solver, using a bisector that handles
variables uniformly, i.e., that uses the same precision value for all of them, is certainly not adequate.</p>
<p>Each bisector can be given a vector of different precisions (one for each variable) instead of a
unique value. We just have to give a <code class="docutils literal notranslate"><span class="pre">Vector</span></code> in argument in place of a <code class="docutils literal notranslate"><span class="pre">double</span></code>.
For instance, with the round-robin bisector:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>    <span class="kt">double</span> <span class="n">_prec</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mf">1e-8</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">,</span><span class="mf">1e-4</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>

    <span class="n">Vector</span> <span class="nf">prec</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">_prec</span><span class="p">);</span>

    <span class="n">RoundRobin</span> <span class="nf">rr</span><span class="p">(</span><span class="n">prec</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="respecting-proportions-of-a-box">
<h3>Respecting proportions of a box<a class="headerlink" href="#respecting-proportions-of-a-box" title="Permalink to this headline">¶</a></h3>
<p>If you want to use a relative precision that respects the proportion betweeen
the interval widths of an “initial” box, you can simply initialize the vector
of precision like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="n">prec</span><span class="o">=</span><span class="mf">1e-07</span><span class="o">*</span><span class="n">box</span><span class="p">.</span><span class="n">diam</span><span class="p">();</span> <span class="c1">// box is the initial domain</span>
</pre></div>
</div>
</div>
<div class="section" id="the-smear-function">
<span id="strategy-smear-function"></span><h3>The Smear Function<a class="headerlink" href="#the-smear-function" title="Permalink to this headline">¶</a></h3>
<p><em>(to be completed)</em></p>
<div class="section" id="smear-function-with-maximum-impact">
<h4>Smear function with maximum impact<a class="headerlink" href="#smear-function-with-maximum-impact" title="Permalink to this headline">¶</a></h4>
<p><em>(to be completed)</em></p>
</div>
<div class="section" id="smear-function-with-maximal-sum-of-impacts">
<h4>Smear function with maximal sum of impacts<a class="headerlink" href="#smear-function-with-maximal-sum-of-impacts" title="Permalink to this headline">¶</a></h4>
<p><em>(to be completed)</em></p>
</div>
<div class="section" id="smear-function-with-maximal-normalized-impact">
<h4>Smear function with maximal normalized impact<a class="headerlink" href="#smear-function-with-maximal-normalized-impact" title="Permalink to this headline">¶</a></h4>
<p><em>(to be completed)</em></p>
</div>
<div class="section" id="smear-function-with-maximal-sum-of-normalized-impacts">
<h4>Smear function with maximal sum of normalized impacts<a class="headerlink" href="#smear-function-with-maximal-sum-of-normalized-impacts" title="Permalink to this headline">¶</a></h4>
<p><em>(to be completed)</em></p>
<p>maximal sum of impacts</p>
</div>
</div>
</div>
<div class="section" id="cell-buffers">
<span id="strategy-cell-buffers"></span><h2>Cell buffers<a class="headerlink" href="#cell-buffers" title="Permalink to this headline">¶</a></h2>
<p><em>(to be completed)</em></p>
<div class="section" id="cell-stack">
<span id="strategy-cell-stack"></span><h3>Cell Stack<a class="headerlink" href="#cell-stack" title="Permalink to this headline">¶</a></h3>
<p><em>(to be completed)</em></p>
</div>
<div class="section" id="cell-heap">
<span id="strategy-cell-heap"></span><h3>Cell Heap<a class="headerlink" href="#cell-heap" title="Permalink to this headline">¶</a></h3>
<p><em>(to be completed)</em></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Strategies</a><ul>
<li><a class="reference internal" href="#box-properties">Box Properties</a><ul>
<li><a class="reference internal" href="#constructor">Constructor</a></li>
<li><a class="reference internal" href="#property-update">Property update</a></li>
<li><a class="reference internal" href="#using-properties">Using properties</a></li>
<li><a class="reference internal" href="#lazy-update">Lazy update</a></li>
<li><a class="reference internal" href="#dependencies">Dependencies</a></li>
<li><a class="reference internal" href="#trust-chain-principle">Trust chain principle</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cov-files">COV files</a><ul>
<li><a class="reference internal" href="#first-example">First example</a></li>
<li><a class="reference internal" href="#exchanging-data-between-ibexsolve-and-ibexopt">Exchanging data between IbexSolve and IbexOpt</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bisectors">Bisectors</a><ul>
<li><a class="reference internal" href="#bisecting-each-component-in-turn">Bisecting each component in turn</a></li>
<li><a class="reference internal" href="#bisecting-the-largest-component">Bisecting the largest component</a></li>
<li><a class="reference internal" href="#setting-different-precision-for-variables">Setting different precision for variables</a></li>
<li><a class="reference internal" href="#respecting-proportions-of-a-box">Respecting proportions of a box</a></li>
<li><a class="reference internal" href="#the-smear-function">The Smear Function</a><ul>
<li><a class="reference internal" href="#smear-function-with-maximum-impact">Smear function with maximum impact</a></li>
<li><a class="reference internal" href="#smear-function-with-maximal-sum-of-impacts">Smear function with maximal sum of impacts</a></li>
<li><a class="reference internal" href="#smear-function-with-maximal-normalized-impact">Smear function with maximal normalized impact</a></li>
<li><a class="reference internal" href="#smear-function-with-maximal-sum-of-normalized-impacts">Smear function with maximal sum of normalized impacts</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#cell-buffers">Cell buffers</a><ul>
<li><a class="reference internal" href="#cell-stack">Cell Stack</a></li>
<li><a class="reference internal" href="#cell-heap">Cell Heap</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="set.html"
                        title="previous chapter">Sets</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="reference.html"
                        title="next chapter">References</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/strategy.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="reference.html" title="References"
             >next</a> |</li>
        <li class="right" >
          <a href="set.html" title="Sets"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IBEX 2.8 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2020, IMT Atlantique.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>