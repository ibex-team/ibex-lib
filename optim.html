
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>IbexOpt &#8212; IBEX 2.8 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Java Plugin (for Choco)" href="java-install.html" />
    <link rel="prev" title="IbexSolve" href="solver.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="java-install.html" title="Java Plugin (for Choco)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="solver.html" title="IbexSolve"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IBEX 2.8 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ibexopt">
<span id="optim"></span><h1>IbexOpt<a class="headerlink" href="#ibexopt" title="Permalink to this headline">¶</a></h1>
<div class="section" id="getting-started">
<span id="optim-run-default"></span><h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>IbexOpt is a end-user program that solves a standard NLP problem (non-linear programming), i.e.,
it minimizes a (nonlinear) objective function under (nonlinear) inequality and equality constraints:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}{\mbox Minimize} \ f(x)\\{\mbox s.t.} \ h(x)=0 \wedge g(x)\leq 0.\end{aligned}\end{align} \]</div>
<p>IbexOpt resorts to a unique black-box strategy (whatever the input problem is) and with a very limited
number of parameters. Needless to say, this strategy is a kind of compromise and not the
best one for a given problem.</p>
<p>Note that this program is based on the <a class="reference internal" href="#optim-generic"><span class="std std-ref">generic optimizer</span></a>, a C++ class
that allows to build a more customizable optimizer.</p>
<p>You can directly apply this optimizer on one of the benchmark problems
distributed with Ibex.
The benchmarks are all written in the <a class="reference internal" href="minibex.html#mod-minibex"><span class="std std-ref">Minibex syntax</span></a> and stored in an arborescence under <code class="docutils literal notranslate"><span class="pre">plugins/optim/benchs/</span></code>.
If you compare the Minibex syntax of these files with the ones given to IbexSolve, you will see that a “minimize”
keyword has appeared.</p>
<p>Open a terminal, move to the <code class="docutils literal notranslate"><span class="pre">bin</span></code> subfolder and run IbexSolve with, for example, the problem named ex3_1_3 located at the specified path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~/ibex-2.8.7$ cd bin
~/ibex-2.8.7/bin$ ./ibexopt ../plugins/optim/benchs/easy/ex3_1_3.bch
</pre></div>
</div>
<p>The following result should be displayed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>************************ setup ************************
  file loaded: ../plugins/optim/benchs/easy/ex3_1_3.bch
*******************************************************

running............

 optimization successful!

 best bound in: [-310.309999984,-309.999999984]
 relative precision obtained on objective function: 0.001  [passed]
 absolute precision obtained on objective function: 0.309999999985  [failed]
 best feasible point: (4.9999999999 ; 1 ; 5 ; 0 ; 5 ; 10)
 cpu time used: 0.00400000000001s.
 number of cells: 1
</pre></div>
</div>
<p>The program has proved that the minimum of the objective lies in a small interval enclosing -310. It also gives
a point close to (5 ; 1 ; 5 ; 0 ; 5 ; 10) which satisfies the constraints and for which
the value taken by the objective function is inside this interval. The process took less than 0.005 seconds.</p>
</div>
<div class="section" id="return-status">
<span id="optim-return"></span><h2>Return status<a class="headerlink" href="#return-status" title="Permalink to this headline">¶</a></h2>
<p>When the optimizer terminates, the following possible status are:</p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>success</strong>:</dt><dd><p>An enclosure of the minimum respecting the precision requirements (<code class="docutils literal notranslate"><span class="pre">--a</span></code> and <code class="docutils literal notranslate"><span class="pre">--r</span></code>)
has been found as well as a global minimizer .
In standard mode (without <code class="docutils literal notranslate"><span class="pre">--rigor</span></code>), equalities are relaxed and the global minimizer is
a point x* satisfying
<span class="math notranslate nohighlight">\(-\varepsilon_h\leq h(^*)\leq\varepsilon_h\)</span>. In rigor mode (<code class="docutils literal notranslate"><span class="pre">--rigor</span></code>), the
global minimizer is a box  <span class="math notranslate nohighlight">\([x^*]\)</span> such that, for some x* inside we do have <span class="math notranslate nohighlight">\(h(x^*)=0\)</span>.
In both cases, for the (explicit or implicit) point x*, f(x*) is also sufficiently closed
to the real global minimum, according to the precision criteria.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>infeasible</strong>:</dt><dd><p>This return status actually corresponds to two different situations. Either the constraints
are not satisfiable (that is, there is not point x simultaneously satisfying all equalities
and inequalities) or the feasible points are all outside the definition domain of the
objective funnction f.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>no feasible point found</strong>:</dt><dd><p>The optimizer could not be able to find a feasible point. This status typically arises
if you control the precision of the bisection (<code class="docutils literal notranslate"><span class="pre">--eps-x</span></code>). Indeed, it may happen, in this case,
that the search stops and no box explored was enough bisected to find a feasible point inside. So the
search is over but the problem was not solved. It may also arise when an inequality
is actually an equality (e.g., <span class="math notranslate nohighlight">\(x^2\leq 0\)</span>), because in non-rigor mode, neither a relaxation nor
an equality satisfaction proof is enforced in this case.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>unbounded objective</strong>:</dt><dd><p>The optimizer could not find a lower bound of the minimum. This means that the objective is very
likely to be unbounded.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>time out</strong>:</dt><dd><p>The time specified with <code class="docutils literal notranslate"><span class="pre">-t</span></code> is reached. Note that this time is only for the solving process itself and
does not count for the system loading step. This means that if the system (the Minibex file) is very big,
you may actually wait longer.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>unreached precision</strong>:</dt><dd><p>This status happens when the search is over but the enclosure on the minimum does not respect the
precision requirements (<code class="docutils literal notranslate"><span class="pre">--a</span></code> and <code class="docutils literal notranslate"><span class="pre">--r</span></code>). It is a similar but slightly better situation than
when the status is <code class="docutils literal notranslate"><span class="pre">no</span> <span class="pre">feasible</span> <span class="pre">point</span> <span class="pre">found</span></code>. The difference is that some feasible points have
been found but some part of the search space could not be processed (neither rejected nor proven
as containing a solution), preventing a good minimum enclosure. An example is when minimizing x
under the constraint <span class="math notranslate nohighlight">\(x^2(x-1)(x-2)\leq0\)</span> in non-rigor mode. Feasible points in the interval
[1,2] are quickly found so that the loup is quickly set to 1. But the lower bound is stuck to 0
as <span class="math notranslate nohighlight">\(x^2\leq 0\)</span> contains a solution (0) which is not found. The problem does not happen in
rigor mode.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="options">
<span id="optim-options"></span><h2>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>-r&lt;<em>float</em>&gt;, –rel-eps-f=&lt;<em>float</em>&gt;</p></td>
<td><p>Relative precision on the objective. Default value is 1e-3.</p></td>
</tr>
<tr class="row-even"><td><p>-a&lt;<em>float</em>&gt;, –abs-eps-f=&lt;<em>float</em>&gt;</p></td>
<td><p>Absolute precision on the objective. Default value is 1e-7.</p></td>
</tr>
<tr class="row-odd"><td><p>–eps-h=&lt;<em>float</em>&gt;</p></td>
<td><p>Equality relaxation value. Default value is 1e-8.</p></td>
</tr>
<tr class="row-even"><td><p>-t&lt;<em>float</em>&gt;, –timeout=&lt;<em>float</em>&gt;</p></td>
<td><p>Timeout (time in seconds). Default value is +oo.</p></td>
</tr>
<tr class="row-odd"><td><p>–random-seed=&lt;<em>float</em>&gt;</p></td>
<td><p>Random seed (useful for reproducibility). Default value is 1.</p></td>
</tr>
<tr class="row-even"><td><p>–eps-x=&lt;<em>float</em>&gt;</p></td>
<td><p>Precision on the variable (<strong>Deprecated</strong>). Default value is 0.</p></td>
</tr>
<tr class="row-odd"><td><p>–initial-loup=&lt;<em>float</em>&gt;</p></td>
<td><p>Initial “loup” (a priori known upper bound).</p></td>
</tr>
<tr class="row-even"><td><p>–rigor</p></td>
<td><p>Activate rigor mode (certify feasibility of equalities).</p></td>
</tr>
<tr class="row-odd"><td><p>–trace</p></td>
<td><p>Activate trace. Updates of loup/uplo are printed while minimizing.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="calling-ibexopt-from-c">
<span id="optim-call-default"></span><h2>Calling IbexOpt from C++<a class="headerlink" href="#calling-ibexopt-from-c" title="Permalink to this headline">¶</a></h2>
<p>Calling the default optimizer is as simple as for the <a class="reference internal" href="solver.html#solver"><span class="std std-ref">default solver</span></a>.
The loaded system must simply correspond to an optimization problem. The default optimizer
is an object of the class <code class="docutils literal notranslate"><span class="pre">DefaultOptimizer</span></code>.</p>
<p>Once the optimizer has been executed(), the main information is stored in three fields,
where f is the objective:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">loup</span></code> (“lo-up”) is the lowest upper bound known for min(f).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uplo</span></code> (“up-lo”) is the uppest lower bound known for min(f).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loup_point</span></code> is the vector for which the value taken by f is less or equal to the loup.</p></li>
</ul>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="cm">/* Build a constrained optimization problem from the file */</span>
  <span class="n">System</span> <span class="nf">sys</span><span class="p">(</span><span class="n">IBEX_OPTIM_BENCHS_DIR</span> <span class="s">&quot;/easy/ex3_1_3.bch&quot;</span><span class="p">);</span>

  <span class="cm">/* Build a default optimizer with a precision set to 1e-07 for f(x) */</span>
  <span class="n">DefaultOptimizer</span> <span class="nf">o</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span><span class="mf">1e-07</span><span class="p">);</span>

  <span class="n">o</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">box</span><span class="p">);</span><span class="c1">// Run the optimizer</span>

  <span class="cm">/* Display the result. */</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;interval for the minimum: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Interval</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">get_uplo</span><span class="p">(),</span><span class="n">o</span><span class="p">.</span><span class="n">get_loup</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;minimizer: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">get_loup_point</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interval</span> <span class="k">for</span> <span class="n">the</span> <span class="n">minimum</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">310.0000308420031</span><span class="p">,</span> <span class="o">-</span><span class="mf">309.999999842</span><span class="p">]</span>
<span class="n">minimizer</span><span class="p">:</span> <span class="p">(</span><span class="o">&lt;</span><span class="mf">4.999999999</span><span class="p">,</span> <span class="mf">4.999999999000001</span><span class="o">&gt;</span> <span class="p">;</span> <span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.000000000000001</span><span class="o">&gt;</span> <span class="p">;</span> <span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="p">;</span> <span class="o">&lt;</span><span class="mf">9.999965300266921e-10</span><span class="p">,</span> <span class="mf">9.999965300266922e-10</span><span class="o">&gt;</span> <span class="p">;</span> <span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="p">;</span> <span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-en-enclosure-of-all-global-minima">
<span id="optim-argmin"></span><h2>Getting en enclosure of all global minima<a class="headerlink" href="#getting-en-enclosure-of-all-global-minima" title="Permalink to this headline">¶</a></h2>
<p>Given a problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}{\mbox Minimize} \ f(x)\\{\mbox s.t.} \ h(x)=0 \wedge g(x)\leq 0\end{aligned}\end{align} \]</div>
<p>IbexOpt gives  a feasible point that is <em>sufficiently</em> close to the real minimum <span class="math notranslate nohighlight">\(f^*\)</span> of the function, i.e., a point
that satisfies</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}{\mbox uplo} \leq f(x)\leq {\mbox loup}\\{\mbox s.t.} \ h(x)=0 \wedge g(x)\leq 0\end{aligned}\end{align} \]</div>
<p>with <em>loup</em> and <em>uplo</em> are respectively a valid upper and lower bound of <span class="math notranslate nohighlight">\(f^*\)</span>, whose accuracy depend on the input precision parameter
(note: validated feasibility with equalities requires ‘’rigor’’ mode).</p>
<p>From this, it is possible, in a second step, to get an enclosure of all global minima thanks to <a class="reference internal" href="solver.html#solver"><span class="std std-ref">IbexSolve</span></a>.
The idea is simply to ask for all the points that satisfy the previous constraints.
We give now a code snippet that illustrate this.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// ========== 1st step ==========</span>
  <span class="c1">// Build the original system: </span>
  <span class="n">Variable</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
  <span class="n">SystemFactory</span> <span class="n">opt_fac</span><span class="p">;</span>
  <span class="n">opt_fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">opt_fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="c1">// minimize f(x)=-x-y</span>
  <span class="n">opt_fac</span><span class="p">.</span><span class="n">add_goal</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">);</span>
  <span class="c1">// s.t. x^2+y^2&lt;=1</span>
  <span class="n">opt_fac</span><span class="p">.</span><span class="n">add_ctr</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">sqr</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">System</span> <span class="nf">opt_sys</span><span class="p">(</span><span class="n">opt_fac</span><span class="p">);</span>
  <span class="c1">// build the default optimizer</span>
  <span class="n">DefaultOptimizer</span> <span class="nf">optimizer</span><span class="p">(</span><span class="n">opt_sys</span><span class="p">,</span><span class="mf">1e-01</span><span class="p">);</span>
  <span class="c1">// run it with (x,y) in R^2</span>
  <span class="n">optimizer</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">IntervalVector</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

  <span class="c1">// ========== 2nd step ==========</span>
  <span class="c1">// Build the auxiliary system</span>
  <span class="n">SystemFactory</span> <span class="n">sol_fac</span><span class="p">;</span>
  <span class="n">sol_fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">sol_fac</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="n">sol_fac</span><span class="p">.</span><span class="n">add_ctr</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">sqr</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">sol_fac</span><span class="p">.</span><span class="n">add_ctr</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">&gt;=</span><span class="n">optimizer</span><span class="p">.</span><span class="n">get_uplo</span><span class="p">());</span>
  <span class="n">sol_fac</span><span class="p">.</span><span class="n">add_ctr</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">&lt;=</span><span class="n">optimizer</span><span class="p">.</span><span class="n">get_loup</span><span class="p">());</span>
  <span class="n">System</span> <span class="nf">sol_sys</span><span class="p">(</span><span class="n">sol_fac</span><span class="p">);</span>
  <span class="n">DefaultSolver</span> <span class="nf">solver</span><span class="p">(</span><span class="n">sol_sys</span><span class="p">,</span><span class="mf">0.01</span><span class="p">);</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">IntervalVector</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="c1">// Get an enclosure of all minima, (under</span>
  <span class="c1">// the form of manifold)</span>
  <span class="k">const</span> <span class="n">CovSolverData</span><span class="o">&amp;</span> <span class="n">minima</span><span class="o">=</span><span class="n">solver</span><span class="p">.</span><span class="n">get_data</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="the-generic-optimizer">
<span id="optim-generic"></span><h2>The generic optimizer<a class="headerlink" href="#the-generic-optimizer" title="Permalink to this headline">¶</a></h2>
<p>Just like the <a class="reference internal" href="solver.html#solver-generic"><span class="std std-ref">generic solver</span></a>, the generic optimizer is the main C++ class
(named <code class="docutils literal notranslate"><span class="pre">Optimizer</span></code>) behind the implementation of IbexOpt.
It takes as the solver:</p>
<ul class="simple">
<li><p>a <strong>contractor</strong></p></li>
<li><p>a <strong>bisector</strong></p></li>
<li><p>a <strong>cell buffer</strong></p></li>
</ul>
<p>but also requires an extra operator:</p>
<ul class="simple">
<li><p>a <strong>loup finder</strong>. A loup finder is in charge of the <em>goal upper bounding</em> step of the optimizer.</p></li>
</ul>
<p>We show below how to re-implement the default optimizer from the generic <code class="docutils literal notranslate"><span class="pre">Optimizer</span></code> class.</p>
</div>
<div class="section" id="implementing-ibexopt-the-default-optimizer">
<span id="optim-implem-default"></span><h2>Implementing IbexOpt (the default optimizer)<a class="headerlink" href="#implementing-ibexopt-the-default-optimizer" title="Permalink to this headline">¶</a></h2>
<p>The contraction performed by the default optimizer is the same as the default solver
(see <a class="reference internal" href="solver.html#solver-implem-default"><span class="std std-ref">Implementing IbexSolve (the default solver)</span></a>) except that it is not applied on the system
itself but the <a class="reference internal" href="system.html#mod-sys-transfo-extend"><span class="std std-ref">Extended System</span></a>.</p>
<p>The loup finder (<code class="docutils literal notranslate"><span class="pre">LoupFinderDefault</span></code>) is a mix of differents strategies. The basic idea is to
create a continuum of feasible points (a box or a polyhedron) where the goal function can be evaluated quickly,
that is, without checking for constraints satisfaction.
The polyhedron (built by a <code class="docutils literal notranslate"><span class="pre">LinearizerXTaylor</span></code> object) corresponds to a <a class="reference internal" href="contractor.html#ctc-linear-relax"><span class="std std-ref">linerization technique</span></a> described in
<a class="reference internal" href="reference.html#araya14"><span class="std std-ref">[Araya et al. 2014]</span></a> and <a class="reference internal" href="reference.html#trombettoni11"><span class="std std-ref">[Trombettoni et al. 2011]</span></a>, based on <em>inner region extraction</em>.
It also resorts to the linerization offered by affine arithmetic (a <code class="docutils literal notranslate"><span class="pre">LinearizerAffine</span></code> object) if the affine plugin is installed.
The box (built by a <code class="docutils literal notranslate"><span class="pre">LoupFinderInHC4</span></code> object) is a technique based on <a class="reference internal" href="interval.html#itv-inner-arith"><span class="std std-ref">inner arithmeric</span></a> also described in
the aforementionned articles.</p>
<p>Finally, by default, the cell buffer (<code class="docutils literal notranslate"><span class="pre">CellDoubleHeap</span></code>) is basically a sorted heap that allows to get in priority boxes minimizing
either the lower or upper bound of the objective enclosure (see <a class="reference internal" href="strategy.html#strategy-cell-heap"><span class="std std-ref">Cell Heap</span></a>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">System</span> <span class="nf">system</span><span class="p">(</span><span class="n">IBEX_OPTIM_BENCHS_DIR</span> <span class="s">&quot;/easy/ex3_1_3.bch&quot;</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">prec</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">;</span> <span class="c1">// precision</span>

  <span class="c1">// normalized system (all inequalities are &quot;&lt;=&quot;)</span>
  <span class="n">NormalizedSystem</span> <span class="nf">norm_sys</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>

  <span class="c1">// extended system (the objective is transformed to a constraint y=f(x))</span>
  <span class="n">ExtendedSystem</span> <span class="nf">ext_sys</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>

  <span class="cm">/* ============================ building contractors ========================= */</span>
  <span class="n">CtcHC4</span> <span class="nf">hc4</span><span class="p">(</span><span class="n">ext_sys</span><span class="p">,</span><span class="mf">0.01</span><span class="p">);</span>

  <span class="n">CtcHC4</span> <span class="nf">hc4_2</span><span class="p">(</span><span class="n">ext_sys</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>

  <span class="n">CtcAcid</span> <span class="nf">acid</span><span class="p">(</span><span class="n">ext_sys</span><span class="p">,</span> <span class="n">hc4_2</span><span class="p">);</span>

  <span class="n">LinearizerXTaylor</span> <span class="nf">linear_relax</span><span class="p">(</span><span class="n">ext_sys</span><span class="p">);</span>

  <span class="n">CtcPolytopeHull</span> <span class="nf">polytope</span><span class="p">(</span><span class="n">linear_relax</span><span class="p">);</span>

  <span class="n">CtcCompo</span> <span class="nf">polytope_hc4</span><span class="p">(</span><span class="n">polytope</span><span class="p">,</span> <span class="n">hc4</span><span class="p">);</span>

  <span class="n">CtcFixPoint</span> <span class="nf">fixpoint</span><span class="p">(</span><span class="n">polytope_hc4</span><span class="p">);</span>

  <span class="n">CtcCompo</span> <span class="nf">compo</span><span class="p">(</span><span class="n">hc4</span><span class="p">,</span><span class="n">acid</span><span class="p">,</span><span class="n">fixpoint</span><span class="p">);</span>
  <span class="cm">/* =========================================================================== */</span>

  <span class="cm">/* Create a smear-function bisection heuristic. */</span>
  <span class="n">SmearSumRelative</span> <span class="nf">bisector</span><span class="p">(</span><span class="n">ext_sys</span><span class="p">,</span> <span class="n">prec</span><span class="p">);</span>

  <span class="cm">/** Create cell buffer (fix exploration ordering) */</span>
  <span class="n">CellDoubleHeap</span> <span class="nf">buffer</span><span class="p">(</span><span class="n">ext_sys</span><span class="p">);</span>

  <span class="cm">/** Create a &quot;loup&quot; finder (find feasible points) */</span>
  <span class="n">LoupFinderDefault</span> <span class="nf">loup_finder</span><span class="p">(</span><span class="n">norm_sys</span><span class="p">);</span>

  <span class="cm">/* Create a solver with the previous objects */</span>
  <span class="n">Optimizer</span> <span class="nf">o</span><span class="p">(</span><span class="n">system</span><span class="p">.</span><span class="n">nb_var</span><span class="p">,</span> <span class="n">compo</span><span class="p">,</span> <span class="n">bisector</span><span class="p">,</span> <span class="n">loup_finder</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">ext_sys</span><span class="p">.</span><span class="n">goal_var</span><span class="p">());</span>

  <span class="cm">/* Run the optimizer */</span>
  <span class="n">o</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">system</span><span class="p">.</span><span class="n">box</span><span class="p">,</span><span class="n">prec</span><span class="p">);</span>

  <span class="cm">/* Display a safe enclosure of the minimum */</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f* in &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Interval</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">get_uplo</span><span class="p">(),</span><span class="n">o</span><span class="p">.</span><span class="n">get_loup</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="cm">/* Report performances */</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cpu time used=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">get_time</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;s.&quot;</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;number of cells=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">get_nb_cells</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">IbexOpt</a><ul>
<li><a class="reference internal" href="#getting-started">Getting started</a></li>
<li><a class="reference internal" href="#return-status">Return status</a></li>
<li><a class="reference internal" href="#options">Options</a></li>
<li><a class="reference internal" href="#calling-ibexopt-from-c">Calling IbexOpt from C++</a></li>
<li><a class="reference internal" href="#getting-en-enclosure-of-all-global-minima">Getting en enclosure of all global minima</a></li>
<li><a class="reference internal" href="#the-generic-optimizer">The generic optimizer</a></li>
<li><a class="reference internal" href="#implementing-ibexopt-the-default-optimizer">Implementing IbexOpt (the default optimizer)</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="solver.html"
                        title="previous chapter">IbexSolve</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="java-install.html"
                        title="next chapter">Java Plugin (for Choco)</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/optim.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="java-install.html" title="Java Plugin (for Choco)"
             >next</a> |</li>
        <li class="right" >
          <a href="solver.html" title="IbexSolve"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IBEX 2.8 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2020, IMT Atlantique.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>