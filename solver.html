
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>IbexSolve &#8212; IBEX 2.8 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="IbexOpt" href="optim.html" />
    <link rel="prev" title="Do it Yourself!" href="lab.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="optim.html" title="IbexOpt"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="lab.html" title="Do it Yourself!"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IBEX 2.8 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ibexsolve">
<span id="solver"></span><h1>IbexSolve<a class="headerlink" href="#ibexsolve" title="Permalink to this headline">¶</a></h1>
<div class="section" id="getting-started">
<span id="solver-run-default"></span><h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>IbexSolve is a end-user program that solves a system of nonlinear equations rigorously
(that is, it does not lose any solution and return each solution under the form of a
small box enclosing the true value). It resorts to
a unique black-box strategy (whatever the input problem is) and with a very limited
number of parameters. Needless to say, this strategy is a kind of compromise and not the
best one for a given problem.</p>
<p>Note that this program is based on the <a class="reference internal" href="#solver-generic"><span class="std std-ref">generic solver</span></a>, a C++ class
that allows to build a more customizable solver.</p>
<p>You can directly apply this solver on one of the benchmark problems
distributed with Ibex.
The benchmarks are all written in the <a class="reference external" href="#func-minibex">Minibex syntax</a> and stored in an arborescence under <code class="docutils literal notranslate"><span class="pre">plugins/solver/benchs/</span></code>.</p>
<p>Open a terminal, move to the <code class="docutils literal notranslate"><span class="pre">bin</span></code> subfolder and run IbexSolve with, for example, the problem named kolev36 located at the specified path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>~/ibex-2.8.0$ cd bin
~/ibex-2.8.0/bin$ ./ibexsolve ../plugins/solver/benchs/others/kolev36.bch
</pre></div>
</div>
<p>The following result should be displayed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>***************************** setup *****************************
  file loaded:         ../plugins/solver/benchs/others/kolev36.bch
  output file:         ../plugins/solver/benchs/others/kolev36.mnf
*****************************************************************

running............

solving successful!

number of inner boxes:         1
number of boundary boxes:      0
number of unknown boxes:       0
number of pending boxes:       0
cpu time used:                 0.0640001s
number of cells:               25

results written in ../plugins/solver/benchs/others/kolev36.mnf
</pre></div>
</div>
<p>The number of “inner boxes” correspond to the number of solutions found (there is just one here). To see the solution, use the option <code class="docutils literal notranslate"><span class="pre">-s</span></code>.</p>
<p>In the report, the “number of cells” correspond to the number of hypothesis (bisections) that was required to solve the problem.</p>
</div>
<div class="section" id="options">
<span id="solver-options"></span><h2>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>-e&lt;<em>float</em>&gt;, –eps-min=&lt;<em>float</em>&gt;</p></td>
<td><p>Minimal width of output boxes. This is a criterion to <em>stop</em> bisection: a
non-validated box will not be larger than ‘eps-min’. Default value is 1e-3.</p></td>
</tr>
<tr class="row-even"><td><p>-E&lt;<em>float</em>&gt;, –eps-max=&lt;<em>float</em>&gt;</p></td>
<td><p>Maximal width of output boxes. This is a criterion to <em>force</em> bisection: a
validated box will not be larger than ‘eps-max’ (unless there is no equality
and it is fully inside inequalities). Default value is +oo (none)</p></td>
</tr>
<tr class="row-odd"><td><p>-t&lt;<em>float</em>&gt;, –timeout=&lt;<em>float</em>&gt;</p></td>
<td><p>Timeout (time in seconds). Default value is +oo (none).</p></td>
</tr>
<tr class="row-even"><td><p>-i&lt;<em>filename</em>&gt;, –input=&lt;<em>filename</em>&gt;</p></td>
<td><p>COV input file. The file contains a (intermediate) description of the
manifold with boxes in the COV (binary) format.</p></td>
</tr>
<tr class="row-odd"><td><p>-o&lt;<em>filename</em>&gt;, –output=&lt;<em>filename</em>&gt;</p></td>
<td><p>COV output file. The file will contain the description of the manifold
with boxes in the COV (binary) format.</p></td>
</tr>
<tr class="row-even"><td><p>–simpl=…</p></td>
<td><p>Expression simplification level. Possible values are:</p>
<ul class="simple">
<li><p>0: no simplification at all (fast).</p></li>
<li><dl class="simple">
<dt>1: basic simplifications (fairly fast).</dt><dd><p>E.g. x+1+1 –&gt; x+2</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2: more advanced simplifications without developing (can be slow).</dt><dd><p>E.g. x*x + x^2 –&gt; 2x^2.
Note that the DAG structure can be lost.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>3: simplifications with full polynomial developing (can blow up!).</dt><dd><p>E.g. x*(x-1) + x –&gt; x^2.
Note that the DAG structure can be lost.</p>
</dd>
</dl>
</li>
</ul>
<p>Default value is : 1.</p>
</td>
</tr>
<tr class="row-odd"><td><p>-s, –sols</p></td>
<td><p>Display the “solutions” (output boxes) on the standard output.</p></td>
</tr>
<tr class="row-even"><td><p>–bfs</p></td>
<td><p>Perform breadth-first search (instead of depth-first search, by default)</p></td>
</tr>
<tr class="row-odd"><td><p>–trace</p></td>
<td><p>Activate trace. “Solutions” (output boxes) are displayed as and when they
are found.</p></td>
</tr>
<tr class="row-even"><td><p>–boundary=…</p></td>
<td><p>Boundary test strength. Possible values are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">true</span></code>: always satisfied. Set by default for under constrained problems
(0&lt;m&lt;n).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">full-rank</span></code>: the gradients of all constraints (equalities and potentially
activated inequalities) must be linearly independent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">half-ball</span></code>: (<strong>not implemented yet</strong>) the intersection of the box and
the solution set is homeomorphic to a half-ball of R^n</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">false</span></code>: never satisfied. Set by default if m=0 or m=n (inequalities
only/square systems)</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>–random-seed=&lt;<em>float</em>&gt;</p></td>
<td><p>Random seed (useful for reproducibility). Default value is 1.</p></td>
</tr>
<tr class="row-even"><td><p>-q, –quiet</p></td>
<td><p>Print no report on the standard output.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="calling-ibexsolve-from-c">
<span id="solver-call-default"></span><h2>Calling IbexSolve from C++<a class="headerlink" href="#calling-ibexsolve-from-c" title="Permalink to this headline">¶</a></h2>
<p>You can call IbexSolve (the default solver) and get the solutions from C++.</p>
<p>Two objects must be built: the first represents the problem (namely, a <a class="reference internal" href="system.html#mod-sys"><span class="std std-ref">system</span></a>), the second
the solver itself. Then, we just run the solver. Here is a simple example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* Build a system of equations from the file */</span>
	<span class="n">System</span> <span class="nf">system</span><span class="p">(</span><span class="n">IBEX_BENCHS_DIR</span> <span class="s">&quot;/others/kolev36.bch&quot;</span><span class="p">);</span>

	<span class="cm">/* Build a default solver for the system and with a precision set to 1e-07 */</span>
	<span class="n">DefaultSolver</span> <span class="nf">solver</span><span class="p">(</span><span class="n">system</span><span class="p">,</span><span class="mf">1e-07</span><span class="p">);</span>

	<span class="n">solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">system</span><span class="p">.</span><span class="n">box</span><span class="p">);</span> <span class="c1">// Run the solver</span>

	<span class="cm">/* Display the solutions. */</span>
	<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">solver</span><span class="p">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> solution n°1 = ([0.1173165676349099, 0.1173165676349106] ; [0.4999999999999989, 0.5000000000000014] ; [0.8826834323650891, 0.8826834323650912] ; [-0.2071067811865488, -0.2071067811865466] ; [1.207106781186544, 1.207106781186553] ; [-2.000000000000004, -1.999999999999998])

</pre></div>
</div>
</div>
<div class="section" id="the-generic-solver">
<span id="solver-generic"></span><h2>The generic solver<a class="headerlink" href="#the-generic-solver" title="Permalink to this headline">¶</a></h2>
<p>The generic solver is the main C++ class behind the implementation of <code class="docutils literal notranslate"><span class="pre">ibexsolve</span></code>.
It is a classical branch and prune algorithm that interleaves contraction and branching (bisection) until
boxes get sufficiently small. However, it performs a more general task that just finding solution points of square
systems of equations: it also knows how to deal with under-constrained systems and handle manifolds.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A more detailed documentation about under-constrained systems will be available soon.</p>
</div>
<p>Compared to <code class="docutils literal notranslate"><span class="pre">ibexsolve</span></code>, the generic solver allows the following additional operators as inputs:</p>
<ol class="arabic">
<li><p>a <strong>contractor</strong></p>
<blockquote>
<div><p>Operator that contracts boxes by removing non-solution points. The contraction operator must be compatible with the
system given (equations/inequalities). The solver performs no check (it is the user responsability). See
<a class="reference internal" href="contractor.html#ctc"><span class="std std-ref">Contractors</span></a>.</p>
</div></blockquote>
</li>
<li><p>a <strong>bisector</strong></p>
<blockquote>
<div><p>Operator that splits a box. Note that some bisectors have a <em>precision</em> parameter: the box is bisected providing
it is large enough. But this precision is not directly seen by the solver which has its own precision variables
(see <code class="docutils literal notranslate"><span class="pre">-e`̀</span>&#160; <span class="pre">and</span> <span class="pre">``-E</span></code>). If however the bisector does not split a box, this will generate an exception caught by the solver,
which will not continue the search and backtrack. So fixing the bisector internal precision gives basically the same effect
as fixing it with <code class="docutils literal notranslate"><span class="pre">--e</span></code>. See <a class="reference internal" href="strategy.html#strategy-bisectors"><span class="std std-ref">Bisectors</span></a> for more details.</p>
</div></blockquote>
</li>
<li><p>a <strong>cell buffer</strong></p>
<blockquote>
<div><p>Operator that manages the list of pending boxes (a <em>cell</em> is a box with a little bit of extra information used by the search).
See <a class="reference internal" href="strategy.html#strategy-cell-buffers"><span class="std std-ref">Cell buffers</span></a> for more details.</p>
</div></blockquote>
</li>
</ol>
<p>Our next example creates a solver for the intersection of two circles of radius <span class="math notranslate nohighlight">\(d\)</span>,
one centered on <span class="math notranslate nohighlight">\((0,0)\)</span> and the other in <span class="math notranslate nohighlight">\((1,0)\)</span>.</p>
<p>To this end we first create a vector-valued function:</p>
<div class="math notranslate nohighlight">
\[\begin{split}(x,y) \mapsto \begin{pmatrix} x^2+y^2-d \\ (x-1)^2+y^2-d \end{pmatrix}\end{split}\]</div>
<p>Then, we build two contractors; a <a class="reference internal" href="contractor.html#ctc-fwd-bwd"><span class="std std-ref">forward-bacwkard</span></a> contractor and (because the system is square),
an <a class="reference internal" href="tutorial.html#tuto-newton"><span class="std std-ref">interval Newton</span></a> contractor.</p>
<p>We chose as bisection operator the <em>round-robin</em> operator, that splits each component in turn.
The precision of the solver is set to 1e-7.</p>
<p>Finally, the cell buffer is a stack, which leads to a depth-first search.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* Create the function (x,y)-&gt;( ||(x,y)||-d,  ||(x,y)-(1,0)||-d ) */</span>
	<span class="n">Variable</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
	<span class="kt">double</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
	<span class="n">Function</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">Return</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">sqr</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">-</span><span class="n">d</span><span class="p">,</span>
		                  <span class="n">sqrt</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">+</span><span class="n">sqr</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">-</span><span class="n">d</span><span class="p">));</span>

	<span class="cm">/* Create the system f(x,y)=0. */</span>
	<span class="n">SystemFactory</span> <span class="n">factory</span><span class="p">;</span>
	<span class="n">factory</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="n">factory</span><span class="p">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
	<span class="n">factory</span><span class="p">.</span><span class="n">add_ctr</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">System</span> <span class="nf">system</span><span class="p">(</span><span class="n">factory</span><span class="p">);</span>

	<span class="cm">/* Create the domain of variables */</span>
	<span class="kt">double</span> <span class="n">init_box</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">},{</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">}</span> <span class="p">};</span>
	<span class="n">IntervalVector</span> <span class="nf">box</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">init_box</span><span class="p">);</span>

	<span class="cm">/* Create a first contractor w.r.t f(x,y)=0 (forward-backward) */</span>
	<span class="n">CtcFwdBwd</span> <span class="nf">fwdBwd</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

	<span class="cm">/* Create a second contractor (interval Newton) */</span>
	<span class="n">CtcNewton</span> <span class="nf">newton</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

	<span class="cm">/* Compose the two contractors */</span>
	<span class="n">CtcCompo</span> <span class="nf">compo</span><span class="p">(</span><span class="n">fwdBwd</span><span class="p">,</span><span class="n">newton</span><span class="p">);</span>

	<span class="cm">/* Create a round-robin bisection heuristic and set the</span>
<span class="cm">	 * precision of boxes to 0. */</span>
	<span class="n">RoundRobin</span> <span class="nf">bisector</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Create a &quot;stack of boxes&quot; (CellStack), which has the effect of</span>
<span class="cm">	 * performing a depth-first search. */</span>
	<span class="n">CellStack</span> <span class="n">buff</span><span class="p">;</span>

	<span class="cm">/* Vector precisions required on variables */</span>
	<span class="n">Vector</span> <span class="nf">prec</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">1e-07</span><span class="p">);</span>

	<span class="cm">/* Create a solver with the previous objects */</span>
	<span class="n">Solver</span> <span class="nf">s</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">compo</span><span class="p">,</span> <span class="n">bisector</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">prec</span><span class="p">);</span>

	<span class="cm">/* Run the solver */</span>
	<span class="n">s</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">box</span><span class="p">);</span>

	<span class="cm">/* Display the solutions */</span>
	<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> solution n°1 = ([0.4999999999999996, 0.5000000000000003] ; [-0.8660254037844389, -0.8660254037844383])
 solution n°2 = ([0.4999999999999998, 0.5000000000000005] ; [0.8660254037844383, 0.8660254037844389])

</pre></div>
</div>
</div>
<div class="section" id="implementing-ibexsolve-the-default-solver">
<span id="solver-implem-default"></span><h2>Implementing IbexSolve (the default solver)<a class="headerlink" href="#implementing-ibexsolve-the-default-solver" title="Permalink to this headline">¶</a></h2>
<p>IbexSolve is an instance of the generic solver with (almost) all parameters set by default.</p>
<p>We already showed how to <a class="reference internal" href="#calling-ibexsolve-from-c">Calling IbexSolve from C++</a>.
To give a further insight into the generic solver and its possible settings, we explain now how to re-create the default solver
by yourself.</p>
<p>The contractor of the default solver is obtained with the following receipe.
This is a <a class="reference internal" href="tutorial.html#tuto-inter-union-compo"><span class="std std-ref">composition</span></a> of</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="contractor.html#ctc-hc4"><span class="std std-ref">HC4</span></a></p></li>
<li><p><a class="reference internal" href="contractor.html#ctc-acid"><span class="std std-ref">ACID</span></a></p></li>
<li><p><a class="reference internal" href="tutorial.html#tuto-newton"><span class="std std-ref">Interval Newton</span></a> (only if it is a square system of equations)</p></li>
<li><dl class="simple">
<dt>A <a class="reference internal" href="tutorial.html#tuto-fixpoint"><span class="std std-ref">fixpoint</span></a> of the <a class="reference internal" href="contractor.html#ctc-polytope-hull"><span class="std std-ref">Polytope Hull</span></a> of two linear relaxations combined:</dt><dd><ul class="simple">
<li><p>the relaxation called X-Taylor;</p></li>
<li><p>the relaxation generated by affine arithmetic. See <a class="reference internal" href="contractor.html#ctc-linear-relax"><span class="std std-ref">Linearizations</span></a>.</p></li>
</ul>
</dd>
</dl>
</li>
</ol>
<p>The bisector is based on the <a class="reference internal" href="strategy.html#strategy-smear-function"><span class="std std-ref">The Smear Function</span></a> with maximal relative impact.</p>
<p>So the following program exactly reproduces the default solver.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>	<span class="n">System</span> <span class="nf">system</span><span class="p">(</span><span class="n">IBEX_BENCHS_DIR</span> <span class="s">&quot;/others/kolev36.bch&quot;</span><span class="p">);</span>

	<span class="cm">/* ============================ building contractors ========================= */</span>
	<span class="n">CtcHC4</span> <span class="nf">hc4</span><span class="p">(</span><span class="n">system</span><span class="p">,</span><span class="mf">0.01</span><span class="p">);</span>

	<span class="n">CtcHC4</span> <span class="nf">hc4_2</span><span class="p">(</span><span class="n">system</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>

	<span class="n">CtcAcid</span> <span class="nf">acid</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">hc4_2</span><span class="p">);</span>

	<span class="n">CtcNewton</span> <span class="nf">newton</span><span class="p">(</span><span class="n">system</span><span class="p">.</span><span class="n">f_ctrs</span><span class="p">,</span> <span class="mf">5e+08</span><span class="p">,</span> <span class="mf">1e-07</span><span class="p">,</span> <span class="mf">1e-04</span><span class="p">);</span>

    <span class="n">LinearizerXTaylor</span> <span class="nf">linear_relax</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>

	<span class="n">CtcPolytopeHull</span> <span class="nf">polytope</span><span class="p">(</span><span class="n">linear_relax</span><span class="p">);</span>

	<span class="n">CtcCompo</span> <span class="nf">polytope_hc4</span><span class="p">(</span><span class="n">polytope</span><span class="p">,</span> <span class="n">hc4</span><span class="p">);</span>

	<span class="n">CtcFixPoint</span> <span class="nf">fixpoint</span><span class="p">(</span><span class="n">polytope_hc4</span><span class="p">);</span>

	<span class="n">CtcCompo</span> <span class="nf">compo</span><span class="p">(</span><span class="n">hc4</span><span class="p">,</span><span class="n">acid</span><span class="p">,</span><span class="n">newton</span><span class="p">,</span><span class="n">fixpoint</span><span class="p">);</span>
	<span class="cm">/* =========================================================================== */</span>

	<span class="cm">/* Create a smear-function bisection heuristic. */</span>
	<span class="n">SmearSumRelative</span> <span class="nf">bisector</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="mf">1e-07</span><span class="p">);</span>

	<span class="cm">/* Create a &quot;stack of boxes&quot; (CellStack) (depth-first search). */</span>
	<span class="n">CellStack</span> <span class="n">buff</span><span class="p">;</span>

	<span class="cm">/* Vector precisions required on variables */</span>
	<span class="n">Vector</span> <span class="nf">prec</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">1e-07</span><span class="p">);</span>

	<span class="cm">/* Create a solver with the previous objects */</span>
	<span class="n">Solver</span> <span class="nf">s</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">compo</span><span class="p">,</span> <span class="n">bisector</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">prec</span><span class="p">);</span>

	<span class="cm">/* Run the solver */</span>
	<span class="n">s</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">system</span><span class="p">.</span><span class="n">box</span><span class="p">);</span>

	<span class="cm">/* Display the solutions */</span>
	<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="cm">/* Report performances */</span>
	<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cpu time used=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">get_time</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;s.&quot;</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;number of cells=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">get_nb_cells</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="parallelizing-search">
<span id="solver-parallel"></span><h2>Parallelizing search<a class="headerlink" href="#parallelizing-search" title="Permalink to this headline">¶</a></h2>
<p>It is possible to parallelize the search by running (in parallel) solvers for different subboxes of the initial box.</p>
<p>Be aware however that Ibex has not been designed (so far) to be parallelized and the following lines only reports our preliminary
experiments.</p>
<p>Here are the important observations:</p>
<ul>
<li><p>The sub-library gaol is <strong>not</strong> thread-safe. You must compile Ibex with <strong>filib</strong> which seems to be OK (see <a class="reference internal" href="install.html#install-options"><span class="std std-ref">Configuration options</span></a>).</p></li>
<li><p>The linear solver Soplex (we have not tested yet with Cplex) seems to be thread-safe but sometimes generates error messages on the
console like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ISOLVE56</span> <span class="n">stop</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">basis</span> <span class="n">status</span><span class="p">:</span> <span class="n">PRIMAL</span> <span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">solver</span> <span class="n">status</span><span class="p">:</span> <span class="n">RUNNING</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>So, calling Soplex several times simultaneously seems not to be allowed, but Soplex at least manages the case properly, that is,
stops. As far as we have observed, we don’t lose solutions even when this kind of message appear.</p>
</li>
<li><p>Ibex objects are not thread-safe which means that the solvers run in parallel must share no information. In particular,
each solver must have its <strong>own copy</strong> of the system.</p></li>
</ul>
<p>Here is an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>	<span class="c1">// Get the system</span>
	<span class="n">System</span> <span class="nf">sys1</span><span class="p">(</span><span class="n">IBEX_BENCHS_DIR</span> <span class="s">&quot;/polynom/ponts-geo.bch&quot;</span><span class="p">);</span>

	<span class="c1">// Create a copy for the second solver</span>
	<span class="n">System</span> <span class="nf">sys2</span><span class="p">(</span><span class="n">sys1</span><span class="p">,</span><span class="n">System</span><span class="o">::</span><span class="n">COPY</span><span class="p">);</span>

	<span class="c1">// Precision of the solution boxes</span>
	<span class="kt">double</span> <span class="n">prec</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">;</span>

	<span class="c1">// Create two solvers</span>
	<span class="n">DefaultSolver</span> <span class="nf">solver1</span><span class="p">(</span><span class="n">sys1</span><span class="p">,</span><span class="n">prec</span><span class="p">);</span>
	<span class="n">DefaultSolver</span> <span class="nf">solver2</span><span class="p">(</span><span class="n">sys2</span><span class="p">,</span><span class="n">prec</span><span class="p">);</span>

	<span class="c1">// Create a partition of the initial box into two subboxes,</span>
	<span class="c1">// by bisecting any variable (here, n°4)</span>
	<span class="n">pair</span><span class="o">&lt;</span><span class="n">IntervalVector</span><span class="p">,</span><span class="n">IntervalVector</span><span class="o">&gt;</span> <span class="n">pair</span><span class="o">=</span><span class="n">sys1</span><span class="p">.</span><span class="n">box</span><span class="p">.</span><span class="n">bisect</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

	<span class="c1">// =======================================================</span>
	<span class="c1">// Run the solvers in parallel</span>
	<span class="c1">// =======================================================</span>
<span class="cp">#pragma omp parallel sections</span>
	<span class="p">{</span>
		<span class="n">solver1</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
<span class="cp">#pragma omp section</span>
		<span class="n">solver2</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="c1">// =======================================================</span>

	<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;solver #1 found &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">solver1</span><span class="p">.</span><span class="n">get_data</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;solver #2 found &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">solver2</span><span class="p">.</span><span class="n">get_data</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>If I remove the <code class="docutils literal notranslate"><span class="pre">#pragma</span></code> the program displays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="c1">#1 found 64</span>
<span class="n">solver</span> <span class="c1">#2 found 64</span>

<span class="n">real</span>  <span class="mi">0</span><span class="n">m5</span><span class="o">.</span><span class="mi">121</span><span class="n">s</span>        <span class="o">//</span> <span class="o">&lt;--------</span> <span class="n">total</span> <span class="n">time</span>
<span class="n">user</span>  <span class="mi">0</span><span class="n">m5</span><span class="o">.</span><span class="mi">088</span><span class="n">s</span>
</pre></div>
</div>
<p>With the <code class="docutils literal notranslate"><span class="pre">#pragma</span></code>, I obtain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="c1">#1 found 64</span>
<span class="n">solver</span> <span class="c1">#2 found 64</span>

<span class="n">real</span>  <span class="mi">0</span><span class="n">m2</span><span class="o">.</span><span class="mi">902</span><span class="n">s</span>        <span class="o">//</span> <span class="o">&lt;--------</span> <span class="n">total</span> <span class="n">time</span>
<span class="n">user</span>  <span class="mi">0</span><span class="n">m5</span><span class="o">.</span><span class="mi">468</span><span class="n">s</span>
</pre></div>
</div>
<p><strong>Note:</strong> It is pure luck that by bisecting the 4th variable, we obtain exactly half of the solutions on each sub-box.
Also, looking for the 64 first solutions takes here around the same time than looking for the 64 subsequent ones, which
is particular to this example. So, contrary to what this example seems to prove, splitting the box in two subboxes does
not divide the running time by two in general. Of course :)</p>
<p>If you are afraid about the messages of the linear solver, you can replace the <code class="docutils literal notranslate"><span class="pre">DefaultSolver</span></code> by your own dedicated solver
that does not resort to the simplex, ex:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>	<span class="n">Vector</span> <span class="nf">eps_min</span><span class="p">(</span><span class="n">sys1</span><span class="p">.</span><span class="n">nb_var</span><span class="p">,</span><span class="n">prec</span><span class="p">);</span>
	<span class="n">Vector</span> <span class="nf">eps_max</span><span class="p">(</span><span class="n">sys1</span><span class="p">.</span><span class="n">nb_var</span><span class="p">,</span><span class="n">POS_INFINITY</span><span class="p">);</span>
	<span class="n">Solver</span> <span class="nf">solver1</span><span class="p">(</span><span class="n">sys1</span><span class="p">,</span><span class="o">*</span><span class="k">new</span> <span class="n">CtcCompo</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="n">CtcHC4</span><span class="p">(</span><span class="n">sys1</span><span class="p">),</span><span class="o">*</span><span class="k">new</span> <span class="n">CtcNewton</span><span class="p">(</span><span class="n">sys1</span><span class="p">.</span><span class="n">f_ctrs</span><span class="p">)),</span> <span class="o">*</span><span class="k">new</span> <span class="n">RoundRobin</span><span class="p">(</span><span class="n">prec</span><span class="p">),</span> <span class="o">*</span><span class="k">new</span> <span class="n">CellStack</span><span class="p">(),</span> <span class="n">eps_min</span><span class="p">,</span> <span class="n">eps_max</span><span class="p">);</span>
	<span class="n">Solver</span> <span class="nf">solver2</span><span class="p">(</span><span class="n">sys2</span><span class="p">,</span><span class="o">*</span><span class="k">new</span> <span class="n">CtcCompo</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="n">CtcHC4</span><span class="p">(</span><span class="n">sys2</span><span class="p">),</span><span class="o">*</span><span class="k">new</span> <span class="n">CtcNewton</span><span class="p">(</span><span class="n">sys2</span><span class="p">.</span><span class="n">f_ctrs</span><span class="p">)),</span> <span class="o">*</span><span class="k">new</span> <span class="n">RoundRobin</span><span class="p">(</span><span class="n">prec</span><span class="p">),</span> <span class="o">*</span><span class="k">new</span> <span class="n">CellStack</span><span class="p">(),</span> <span class="n">eps_min</span><span class="p">,</span> <span class="n">eps_max</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">IbexSolve</a><ul>
<li><a class="reference internal" href="#getting-started">Getting started</a></li>
<li><a class="reference internal" href="#options">Options</a></li>
<li><a class="reference internal" href="#calling-ibexsolve-from-c">Calling IbexSolve from C++</a></li>
<li><a class="reference internal" href="#the-generic-solver">The generic solver</a></li>
<li><a class="reference internal" href="#implementing-ibexsolve-the-default-solver">Implementing IbexSolve (the default solver)</a></li>
<li><a class="reference internal" href="#parallelizing-search">Parallelizing search</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="lab.html"
                        title="previous chapter">Do it Yourself!</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="optim.html"
                        title="next chapter">IbexOpt</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/solver.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="optim.html" title="IbexOpt"
             >next</a> |</li>
        <li class="right" >
          <a href="lab.html" title="Do it Yourself!"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IBEX 2.8 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2020, IMT Atlantique.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>